---
title: "Getting Started with BiocNMF"
author: "Michael Totty"
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
    toc_float: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Getting Started with BiocNMF}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 10,
  fig.height = 8
)
```

# Introduction

BiocNMF provides fast, scalable non-negative matrix factorization (NMF) for single-cell and spatial genomics data. NMF decomposes gene expression data into biologically interpretable gene expression programs and their usage patterns across cells.

## Why NMF?

- **Biologically interpretable**: Gene programs contain only positive weights
- **Parts-based decomposition**: Identifies co-expressed gene modules  
- **Cell type discovery**: Programs often correspond to cell type signatures
- **Additive mixing**: Cells can express multiple programs simultaneously

BiocNMF uses RcppML for high-performance computation and integrates seamlessly with Bioconductor workflows.

```{r load-packages}
library(BiocNMF)
library(SingleCellExperiment)
library(scuttle)
library(scater)
library(scran)
library(scRNAseq)
library(ggplot2)
library(patchwork)
```

# Basic NMF Workflow

## Load and prepare data

We'll use the Zeisel brain dataset (Zeisel et al. 2015, Science) which contains diverse brain cell types.

```{r prepare-data}
# Load brain dataset
sce <- ZeiselBrainData()
cat("Original data:", nrow(sce), "genes,", ncol(sce), "cells\n")

# Quality control and filtering
sce <- addPerCellQCMetrics(sce)
sce <- addPerFeatureQCMetrics(sce)
sce <- sce[rowData(sce)$detected >= 10, ]  # Genes detected in ≥10 cells
sce <- sce[, colData(sce)$detected >= 500]  # Cells with ≥500 detected genes

# Subset to 1000 cells for computational efficiency
set.seed(42)
if (ncol(sce) > 1000) {
  cell_subset <- sample(ncol(sce), 1000)
  sce <- sce[, cell_subset]
}

# Normalize and select highly variable genes
sce <- logNormCounts(sce)
dec <- modelGeneVar(sce)
top_hvgs <- getTopHVGs(dec, n = 1000)  # Top 1000 HVGs
sce <- sce[top_hvgs, ]

cat("Final data:", nrow(sce), "genes,", ncol(sce), "cells\n")
```

## Run NMF

```{r run-nmf}
# Run NMF with 8 programs (good for brain cell diversity)
sce <- runBiocNMF(sce, k = 8, verbose = FALSE)

# Check results
cat("NMF programs stored in:", reducedDimNames(sce), "\n")
cat("Basis matrix stored in:", names(metadata(sce)), "\n")
```

## Add dimension reductions for visualization

```{r dim-reduction}
# Run PCA and UMAP for visualization
sce <- runPCA(sce, ncomponents = 50)
sce <- runUMAP(sce, dimred = "PCA")

cat("Available dimension reductions:", reducedDimNames(sce), "\n")
```

# Visualizing NMF Results

## Plot NMF programs on UMAP

BiocNMF provides convenient visualization functions to plot NMF program usage on dimension reduction coordinates.

```{r visualize-programs, fig.width=12, fig.height=6}
# Visualize two distinct NMF programs
p1 <- vizUMAP(sce, program = 1, title = "NMF Program 1")
p2 <- vizUMAP(sce, program = 3, title = "NMF Program 3", color_scale = "plasma")

# Display side by side
p1 + p2
```

```{r visualize-comparison, fig.width=12, fig.height=8}
# Compare with known cell types
p3 <- plotReducedDim(sce, dimred = "UMAP", colour_by = "level1class", 
                     point_size = 0.8) +
  ggtitle("Known Cell Types") +
  theme(legend.position = "right")

# Show NMF programs vs cell types
(p1 + p2) / p3
```

## Examine top genes per program

```{r top-genes}
# Get top contributing genes for each program
top_genes <- getTopFeatures(sce, n = 10)

# Display top genes for first few programs
for (i in 1:4) {
  cat("Program", i, "top genes:", paste(top_genes[[i]][1:5], collapse = ", "), "...\n")
}
```

# Key Functions

- **`runBiocNMF()`**: Run NMF decomposition
- **`getBasis()`**: Extract gene expression programs (genes × programs)
- **`getCoefficients()`**: Extract program usage (cells × programs)  
- **`getTopFeatures()`**: Get top genes per program
- **`vizUMAP()`**: Visualize programs on UMAP coordinates
- **`vizDimRed()`**: Visualize programs on any dimension reduction

# Session Information

```{r session-info}
sessionInfo()
```